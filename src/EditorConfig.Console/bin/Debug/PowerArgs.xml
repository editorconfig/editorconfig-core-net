<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PowerArgs</name>
    </assembly>
    <members>
        <member name="T:PowerArgs.IArgMetadataEx">
            <summary>
            Extension methods that make it easy to work with metadata collections
            </summary>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.HasMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Returns true if the given collection of metadata contains metadata of the generic type T
            provided.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>rue if the given collection of metadata contains metadata of the generic type T
            provided, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Meta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the first instance of metadata of the given generic type T in the collection
            or null if it was not found.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the first instance of an metadata of the given generic type T in the collection
            or null if it was not found</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.TryGetMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata},``0@)">
            <summary>
            Try to get the first instance of metadata of the given generic type T in the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <param name="ret">the our variable to set if the metadata was found</param>
            <returns>true if the metadata was found, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Metas``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the subset of metadata of the given generic type T from the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the subset of metadata of the given generic type T from the collection</returns>
        </member>
        <member name="T:PowerArgs.MatchCollectionEx">
            <summary>
            A simple helper that makes it possible to do Linq queries over a MatchCollection
            </summary>
        </member>
        <member name="M:PowerArgs.MatchCollectionEx.ToList(System.Text.RegularExpressions.MatchCollection)">
            <summary>
            Converts a MatchCollection to a List of Match objects so that you can perform linq queries over the matches.
            </summary>
            <param name="matches">The MatchCollection to convert</param>
            <returns>a list of Match objects</returns>
        </member>
        <member name="T:PowerArgs.MemberInfoEx">
            <summary>
            Provides some reflection helpers in the form of extension methods for the MemberInfo type.
            </summary>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.HasAttr``1(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the given member has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The member to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attr``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attribute of the given type or null if the member does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attrs``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.ParemeterInfoEx">
            <summary>
            Some useful helper extensions for the ParameterInfo type
            </summary>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.HasAttr``1(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if the given parameter has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The parameter to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attr``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attribute of the given type or null if the parameter does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attrs``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.AliasCollection">
            <summary>
            This class tracks the command line aliases for a CommandLineArgument and a CommandLineAction.
            It combines the aliases that have been retrieved from the ArgShortcut attibute and any additional
            aliases that may have been added to the model manually into a single collection.  It also makes sure that those two sources
            of aliases don't conflict.
            
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.IndexOf(System.String)">
            <summary>
            Gets the index of the given alias in the collection.
            </summary>
            <param name="item">the alias to look for</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.Insert(System.Int32,System.String)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
            <param name="item">Not supported</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.RemoveAt(System.Int32)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.AddRange(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds the given aliases to the collection. 
            </summary>
            <param name="items">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Add(System.String)">
            <summary>
            Adds the given alias to the collection.  An InvalidArgDefinitionException is thrown if you try to add
            the same alias twice (case sensitivity is determined by the CommandLineArgument or CommandLineAction).
            </summary>
            <param name="item">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Clear">
            <summary>
            Clear is not supported, use ClearOverrides() to clear items that have manually been added
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.ClearOverrides">
            <summary>
            Clears the aliases that have been manually addd to this collection via Add() or AddRange().
            Aliases that are inferred from the Metadata will still be present in the collection. 
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.Contains(System.String)">
            <summary>
            Tests to see if this Alias collection contains the given item.  Case sensitivity is enforced
            based on the CommandLineArgument or CommandLineAction.
            </summary>
            <param name="item">The item to test for containment</param>
            <returns>True if the collection contains the item, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.CopyTo(System.String[],System.Int32)">
            <summary>
            Copies this collection to an array, starting at the given index
            </summary>
            <param name="array">the destination array</param>
            <param name="arrayIndex">the starting index of where to place the elements into the destination</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Remove(System.String)">
            <summary>
            Removes the given alias from the collection if it was added via Add() or AddRange().  If
            it was added by injecting metadata into a CommandLineArgument or a CommandLineAction then
            an InvalidOperationException will be thrown.  The correct way to remove metadata injected
            aliases is to remove it from the metadata directly.
            </summary>
            <param name="item">the item to remove</param>
            <returns>true if the alias was removed, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="P:PowerArgs.AliasCollection.Item(System.Int32)">
            <summary>
            The setter is not supported.  The getter returns the item at the specified index.
            </summary>
            <param name="index"></param>
            <returns>the item at the specified index</returns>
        </member>
        <member name="P:PowerArgs.AliasCollection.Count">
            <summary>
            Gets the count of aliases
            </summary>
        </member>
        <member name="P:PowerArgs.AliasCollection.IsReadOnly">
            <summary>
            Not read only ever
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAction`1">
            <summary>
            This is the more complex version of the public result that is produced by the parser.
            </summary>
            <typeparam name="T">Represents the custom argument scaffold type that was passed to the parser.</typeparam>
        </member>
        <member name="T:PowerArgs.ArgAction">
            <summary>
            This is the weakly typed, more complex version of the public result that is produced by the parser.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAction.Invoke">
            <summary>
            This will find the implementation method for your action and invoke it, passing the action specific
            arguments as a parameter.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Definition">
            <summary>
            The definition or model that was used to parse the arguments
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Value">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgs">
            <summary>
            If you used the action framework then this will represent the instance of the action specific arguments
            that were parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgsProperty">
            <summary>
            If you used the action framework then this will map to the property that the user specified as the first
            parameter on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionParameters">
            <summary>
            This is set if you defined your action via a method with simple parameters
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.HandledException">
            <summary>
            If an exception was handled by the parser then this property will be populated and others will not be.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Cancelled">
            <summary>
            If processing was cancelled then this property will be set to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction`1.Args">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleHelper">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="F:PowerArgs.ConsoleHelper.ConsoleImpl">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleHelper.ParseContext(System.String)">
            <summary>
            The input is the full command line previous to the token to be completed.  This function 
            pulls out the last token before the completion's 'so far' input.
            </summary>
            <param name="commandLine"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.BooleanExpressionParser">
            <summary>
            A simple boolean expression parser that supports and '&amp;', or '|', and grouping via parentheses.
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Parse(System.String)">
            <summary>
            Parses the given boolean expression which can be made up of variables and boolean operators (and '&amp;' and or '|') grouped by parentheses.
            </summary>
            <param name="expressionText">The expression to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Revive(System.String,System.String)">
            <summary>
            A reviver that makes boolean expressions specificable on the command line
            </summary>
            <param name="key">not used</param>
            <param name="val">the expression text</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.BooleanOperator">
            <summary>
            Represents the set of supported boolean operators
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.And">
            <summary>
            Represents an 'and' boolean operation
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.Or">
            <summary>
            Represents an 'or' boolean operation
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionTokenType">
            <summary>
            An enum representing a type of boolean expression token
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Variable">
            <summary>
            Represents a boolean variable
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupOpen">
            <summary>
            Represents the beginning of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupClose">
            <summary>
            Represents the end of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.And">
            <summary>
            Represents an 'and' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Or">
            <summary>
            Represents an 'or' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Not">
            <summary>
            Indicates that an expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionToken">
            <summary>
            A class that represents a boolean expression token
            </summary>
        </member>
        <member name="T:PowerArgs.Token">
            <summary>
            A base token class that represents a substring from a document.  The location in the source
            document is tracked along with the substring so that code that processes the token can indicate
            where problems are to the user who supplied the document if needed.
            </summary>
        </member>
        <member name="M:PowerArgs.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a token given an initial value, a start index, a line number, and a column number
            </summary>
            <param name="initialValue">The initial value of a token.  You can append to the token later</param>
            <param name="startIndex">the zero based start index of this token in the document</param>
            <param name="line">the 1 based line number of the token in the document</param>
            <param name="col">the 1 based index of the token within it's line</param>
        </member>
        <member name="M:PowerArgs.Token.ToString">
            <summary>
            Gets a string representation of the token, along with position info
            </summary>
            <returns>a string representation of the token, along with position info</returns>
        </member>
        <member name="M:PowerArgs.Token.As``1">
            <summary>
            Creates a new instance of the strongly typed token and copies all of the base token's properties to the new value
            </summary>
            <typeparam name="T">The type of the derived token.</typeparam>
            <returns>The strongly typed token</returns>
        </member>
        <member name="P:PowerArgs.Token.Value">
            <summary>
            Gets the value of the token
            </summary>
        </member>
        <member name="P:PowerArgs.Token.StartIndex">
            <summary>
            Gets the zero based start index of this token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.SourceFileLocation">
            <summary>
            Gets a string that represents the source file of this document.  It does not need to be a file name, but it usually is.
            </summary>
        </member>
        <member name="P:PowerArgs.Token.EndIndex">
            <summary>
            Gets the end index of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Line">
            <summary>
            Gets the 1 based line number of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Column">
            <summary>
            Gets the 1 based index of the token within it's line
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Position">
            <summary>
            Gets a string that represents the position of this token in the source document. 
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a boolean expression token
            </summary>
            <param name="tokenText">the token text</param>
            <param name="startIndex">the start index of the token value</param>
            <param name="line">the line number of the token value</param>
            <param name="col">the column number of the token value</param>
        </member>
        <member name="P:PowerArgs.BooleanExpressionToken.Type">
            <summary>
            The type of token
            </summary>
        </member>
        <member name="T:PowerArgs.IBooleanVariableResolver">
            <summary>
            An interface that describes how to resolve boolean variables that can be either true or false
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Implementations should provide a value of true or false for each variable specified.  Implementations can
            choose how to handle unknown variables either by throwing or returning a default value.
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.FuncBooleanVariableResolver">
            <summary>
            A class that can resolve a boolean variable based on a function.
            </summary>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.#ctor(System.Func{System.String,System.Boolean})">
            <summary>
            Creates a new variable resolver given an implementation as a function.
            </summary>
            <param name="resolverImpl"></param>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Resolves the given variable using the wrapped function
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.FuncBooleanVariableResolver.ResolverImpl">
            <summary>
            The function that knows how to resolve boolean variables
            </summary>
        </member>
        <member name="T:PowerArgs.IBooleanExpression">
            <summary>
            An interface representing a node in a boolean expression that can either be true or false.
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the state of the node (true or false) given a variable resolver.
            </summary>
            <param name="resolver">the object to use to resolve boolean variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the state of the node (true or false) given a set of variable values.
            </summary>
            <param name="variableValues">The current state of variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="P:PowerArgs.IBooleanExpression.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanVariable">
            <summary>
            A node in a boolean expression that represents a variable that can either be true or false.
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Uses the given resolver to resolve the target boolean variable
            </summary>
            <param name="resolver">The object used to resolve boolean variables</param>
            <returns>the result of the resolver</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="P:PowerArgs.BooleanVariable.Not">
            <summary>
            Gets or sets a flag indicating that the variable's value should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanVariable.VariableName">
            <summary>
            The name of the variable referenced by this node
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionGroup">
            <summary>
            A class that represents a boolean expression that supports and, or, and grouping.
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.#ctor">
            <summary>
            Creates a new empty boolean expression
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the expression given a variable resolver.
            </summary>
            <param name="resolver">An object used to resolve variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operands">
            <summary>
            The operands (variables or grouped child expressions) that make up this expression.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operators">
            <summary>
            The operators to apply between each operand
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleCharacter">
            <summary>
            A wrapper for char that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.#ctor(System.Char,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a new ConsoleCharacter given a char value and optionally set the foreground or background coor.
            </summary>
            <param name="value">The character value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Write">
            <summary>
            Write this formatted character to the console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToString">
            <summary>
            Gets the string representation of the character
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Equals(System.Object)">
            <summary>
            ConsoleCharacters can be compared to other ConsoleCharacter instances or char values.
            </summary>
            <param name="obj">The ConsoleCharacter or char to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GetHashCode">
            <summary>
            Override of GetHashcode that returns the internal char's hashcode.
            </summary>
            <returns>the internal char's hashcode.</returns>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.Value">
            <summary>
            The value of the character
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.ForegroundColor">
            <summary>
            The console foreground color to use when printing this character.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.BackgroundColor">
            <summary>
            The console background color to use when printing this character.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleString">
            <summary>
            A wrapper for string that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor">
            <summary>
            Create a new empty ConsoleString
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a ConsoleString given an initial text value and optional color info.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Append(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Appends the given value to this ConsoleString using the given formatting.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Append(PowerArgs.ConsoleString)">
            <summary>
            Concatenates two ConsoleStrings together.
            </summary>
            <param name="other">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.AppendUsingCurrentFormat(System.String)">
            <summary>
            Appends the given value using the formatting of the last character or the default formatting if this ConsoleString is empty.
            </summary>
            <param name="value">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Replace(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all occurrances of the given string with the replacement value using the specified formatting.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns>A new ConsoleString with the replacements.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ReplaceRegex(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all matches of the given regular expression with the replacement value using the specified formatting.
            </summary>
            <param name="regex">The regular expression to find.</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.IndexOf(System.String)">
            <summary>
            Finds the index of a given substring in this ConsoleString.
            </summary>
            <param name="toFind">The substring to search for.</param>
            <returns>The first index of the given substring or -1 if the substring was not found.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Contains(System.String)">
            <summary>
            Determines if this ConsoleString contains the given substring.
            </summary>
            <param name="substr">The substring to search for.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index.
            </summary>
            <param name="start">the start index.</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32,System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index and with the given length.
            </summary>
            <param name="start">the start index.</param>
            <param name="length">the number of characters to return</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write">
            <summary>
            Write this ConsoleString to the console using the desired style.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToString">
            <summary>
            Get the string representation of this ConsoleString.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Equals(System.Object)">
            <summary>
            Compare this ConsoleString to another ConsoleString or a plain string.
            </summary>
            <param name="obj">The ConsoleString or plain string to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.CompareTo(System.String)">
            <summary>
            Compare this ConsoleString to another ConsoleString.
            </summary>
            <param name="other">The ConsoleString to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns>the hashcode of the underlying string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Operator overload that concatenates 2 ConsoleString instances and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,System.String)">
            <summary>
            Operator overload that concatenates a ConsoleString with a string and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Equality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for equality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>True if they are the same, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Inequality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for inequality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>False if they are the same, true otherwise</returns>
        </member>
        <member name="P:PowerArgs.ConsoleString.Empty">
            <summary>
            Represents an empty string.  You will get a new instance each time you access this property.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.Length">
            <summary>
            The length of the string.
            </summary>
        </member>
        <member name="T:PowerArgs.Args">
            <summary>
            The main entry point for PowerArgs that includes the public parsing functions such as Parse, ParseAction, and InvokeAction.
            </summary>
        </member>
        <member name="M:PowerArgs.Args.SearchAssemblyForRevivers(System.Reflection.Assembly)">
            <summary>
            PowerArgs will manually search the assembly you provide for any custom type revivers.  If you don't specify an
            assembly then the assembly that calls this function will automatically be searched.
            </summary>
            <param name="a">The assembly to search or null if you want PowerArgs to search the assembly that's calling into this function.</param>
        </member>
        <member name="M:PowerArgs.Args.Convert(System.String)">
            <summary>
            Converts a single string that represents a command line to be executed into a string[], 
            accounting for quoted arguments that may or may not contain spaces.
            </summary>
            <param name="commandLine">The raw arguments as a single string</param>
            <returns>a converted string array with the arguments properly broken up</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs``1">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <typeparam name="T">The scaffold type for your arguments</typeparam>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs(System.Type)">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <param name="t">The scaffold type for your arguments</param>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(System.Type,System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the args for the given definition and then calls the Main() method defined by the type.
            </summary>
            <param name="definition"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain``1(System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  Then, invokes the action
            that was specified.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and actions.</param>
            <param name="args"></param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition. The values will be populated within
            the definition.
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
        </member>
        <member name="T:PowerArgs.ArgUsageOptions">
            <summary>
            A class that lets you customize how your usage displays
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsageOptions.#ctor">
            <summary>
            Creates a new instance of ArgUsageOptions
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowType">
            <summary>
            Set to true if you want to show the type column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowPosition">
            <summary>
            Set to true if you want to show the position column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums, true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.AppendDefaultValueToDescription">
            <summary>
            Set to true if you want to show default values after the description (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.SpecifiedActionOverride">
            <summary>
            Set this to ensure the usage generator only shows usage info for the specified action.  You will typically
            populate this by looking at the ArgException that you're probably catching.
            </summary>
        </member>
        <member name="T:PowerArgs.UsageHook">
            <summary>
            An attribute used to hook into the usage generation process and influence
            the content that is written.
            </summary>
        </member>
        <member name="T:PowerArgs.IGlobalArgMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments, CommandLineActions, and CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments
            </summary>
        </member>
        <member name="T:PowerArgs.IArgMetadata">
            <summary>
            Any attribute that's purpose is to add information about a command line arguments definiton should
            derive from this type.  
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentsDefinitionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="M:PowerArgs.UsageHook.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            This hook gets called when the property it is attached to is having
            its usage generated.  You can override this method and manipulate the
            properties of the given usage info object.
            </summary>
            <param name="info">An object that you can use to manipulate the usage output.</param>
        </member>
        <member name="E:PowerArgs.UsageHook.HookExecuting">
            <summary>
            An event you can subscribe to in the case where you created
            your hook in running code rather than as a declarative attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgumentUsageInfo">
            <summary>
            A class that represents usage info to be written to the console.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentUsageInfo.#ctor(PowerArgs.CommandLineArgument)">
            <summary>
            Generate a new info instance given a reflected property. 
            </summary>
            <param name="toAutoGen">The property to use to seed the usage info</param>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Name">
            <summary>
            The name that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Aliases">
            <summary>
            Aliases for this argument that will be honored by the parser.  This
            includes shortcuts and long form aliases, but can be extended further.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.PossibleValues">
            <summary>
            Possible values for this option.  This is auto populated for enums and includes the description if specified.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsRequired">
            <summary>
            Indicates that the argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Type">
            <summary>
            The friendly type name that will be displayed to the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Position">
            <summary>
            The expected position of the argument, or null if not a positioning is not supported for the given argument.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Description">
            <summary>
            The description that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Ignore">
            <summary>
            If set to true, the argument usage will not be written.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsAction">
            <summary>
            True if this is the "Action" property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsActionArgs">
            <summary>
            True if this represents a nested action argument property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Property">
            <summary>
            The reflected property that this info object represents
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Argument">
            <summary>
            The command line argument that the system is currently generating usage for
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.DefaultValue">
            <summary>
            The default value for the argument
            </summary>
        </member>
        <member name="T:PowerArgs.ArgUsage">
            <summary>
            A helper class that generates usage documentation for your command line arguments given a custom argument
            scaffolding type.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsage.RegisterHook(System.Reflection.PropertyInfo,PowerArgs.UsageHook)">
            <summary>
            Registers a usage hook for the given property.
            </summary>
            <param name="prop">The property to hook into or null to hook into all properties.</param>
            <param name="hook">The hook implementation.</param>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate``1(System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(System.Type,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="t">The command line argument definition scaffold type</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <param name="templateSourceLocation">The source of the template, usually a file name</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser``1(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetUsage``1(System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates usage documentation for the given argument scaffold type.
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetUsage(PowerArgs.CommandLineArgumentsDefinition,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates usage documentation for the given argument definition.
            </summary>
            <param name="definition">The definition of the command line arguments for a program</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage``1(System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage(System.Type,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <param name="t">Your custom argument scaffold type</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage(PowerArgs.CommandLineArgumentsDefinition,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given arguments definition.  
            </summary>
            <param name="definition">The definition of the command line arguments for a program</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="T:PowerArgs.EasterEggs.MatrixMode">
            <summary>
            An easter egg that makes all command line output get written in a green themed, futuristic fasion.  Don't use in a real program :).
            Breaking changes are allowed in the PowerArgs.EasterEggs namespace.
            </summary>
        </member>
        <member name="M:PowerArgs.EasterEggs.MatrixMode.Start">
            <summary>
            Starts MatrixMode.
            </summary>
            <returns>An action that when invoked stops MatrixMode.</returns>
        </member>
        <member name="T:PowerArgs.ArgException">
            <summary>
            An exception that should be thrown when the error condition is caused because of bad user input.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="P:PowerArgs.ArgException.Context">
            <summary>
            The parser context that may be incomplete since it depends on where the exception was thrown
            </summary>
        </member>
        <member name="T:PowerArgs.InvalidArgDefinitionException">
            <summary>
            An exception that should be thrown when the error condition is caused by an improperly formed
            argument scaffold type.  For example if the user specified the same shortcut value for more than one property.
            </summary>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnexpectedArgException">
            <summary>
            An exception that should be thrown when an unexpected named|positional argument is found.
            </summary>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.DuplicateArgException">
            <summary>
            An exception that should be thrown when the same argument is repeated.
            </summary>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.MissingArgException">
            <summary>
            An exception that should be thrown when a required argument is missing.
            </summary>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnknownActionArgException">
            <summary>
            An exception that should be thrown when an unknown action argument is specified.
            </summary>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.QueryInvalidArgException">
            <summary>
            An exception that should be thrown when the query can not be compiled.
            </summary>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.ValidationArgException">
            <summary>
            An exception that should be thrown when an argument's value is not valid.
            </summary>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionSource">
            <summary>
            An abstract class that can be used to implement tab completion logic that is specific to a given argument.
            </summary>
        </member>
        <member name="T:PowerArgs.ITabCompletionSource">
            <summary>
            An interface used to implement custom tab completion logic.
            </summary>
        </member>
        <member name="M:PowerArgs.ITabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            PowerArgs will call this method if it has enhanced the command prompt and the user presses tab.  You should use the
            text the user has types so far to determine if there is a completion you'd like to make.  If you find a completion
            then you should assign it to the completion variable and return true.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>True if you completed the string, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Internal implementation that determines whether or not the context matches the target command line argument
            </summary>
            <param name="shift">true if the shift key was pressed along with the tab key</param>
            <param name="context">the completed token that appeared on the command line before the current, incomplete token that's being tabbed through</param>
            <param name="soFar">the incomplete token</param>
            <param name="completion">the completion to populate</param>
            <returns>true if completion was successful, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,PowerArgs.CommandLineArgument,System.String,System.String@)">
            <summary>
            The abstract method that should be implemented to perform some tab completion logic
            </summary>
            <param name="shift">true if the shift key was pressed along with the tab key</param>
            <param name="target">the command line argument that the soFar token is going to apply to</param>
            <param name="soFar">the incomplete token</param>
            <param name="completion">the completion to populate</param>
            <returns>true if completion was successful, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented
            </summary>
            <param name="shift">Not implemented</param>
            <param name="soFar">Not implemented</param>
            <param name="completion">Not implemented</param>
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="T:PowerArgs.IConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Clear">
            <summary>
            Clears the console window
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorTop">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.BufferWidth">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="T:PowerArgs.StdConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadALineOfConsoleOutput(System.Int32)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="y">Used for internal implementation, but marked public for testing, please do not use.</param>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Clear">
            <summary>
            Clears the console
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorTop">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.BufferWidth">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="T:PowerArgs.IUsageTemplateProvider">
            <summary>
            An interface that defines how usage templates should be retrieved
            </summary>
        </member>
        <member name="M:PowerArgs.IUsageTemplateProvider.GetTemplate">
            <summary>
            Gets the usage template to render
            </summary>
            <returns>usage template to render</returns>
        </member>
        <member name="T:PowerArgs.DefaultConsoleUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default console usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultConsoleUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default console usage template
            </summary>
            <returns>the default console usage template</returns>
        </member>
        <member name="T:PowerArgs.DefaultBrowserUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default browser usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultBrowserUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default browser usage template
            </summary>
            <returns>the default browser usage template</returns>
        </member>
        <member name="T:PowerArgs.ParseResult">
            <summary>
            The raw parse result that contains the dictionary of values that were parsed
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ExplicitParameters">
            <summary>
            Dictionary of values that were either in the format -key value or /key:value on
            the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ImplicitParameters">
            <summary>
            Dictionary of values that were implicitly specified by position where the key is the position (e.g. 0)
            and the value is the actual parameter value.
            
            Example command line:  Program.exe John Smith
            
            John would be an implicit parameter at position 0.
            Smith would be an implicit parameter at position 1.
            </summary>
        </member>
        <member name="T:PowerArgs.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.DefaultBrowserUsageTemplate">
             <summary>
               Looks up a localized string similar to &lt;!DOCTYPE html&gt;
            &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
            &lt;head&gt;
                &lt;title&gt;{{ExeName!}} documentation&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
            &lt;h1 class=&quot;program-specific-content&quot;&gt;{{ExeName!}}&lt;/h1&gt;
            &lt;p class=&quot;program-specific-content&quot;&gt;{{Description!}}&lt;/p&gt;
            
            &lt;h2&gt;Usage&lt;/h2&gt;
            &lt;pre class=&quot;code-sample&quot;&gt;{{UsageSummaryHTMLEncoded!}}&lt;/pre&gt;
            
            {{if HasGlobalArguments}}
            	{{if HasActions}}&lt;h2&gt;Global options&lt;/h2&gt;!{{if}}
            	{{ifnot HasActions}}&lt;h2&gt;Options&lt;/h2&gt;!{{ifnot}}
            
            	&lt;table&gt;
            		&lt;tr&gt;
            			&lt;td class=&quot;option-col table-header [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:PowerArgs.Resources.DefaultConsoleUsageTemplate">
             <summary>
               Looks up a localized string similar to {{ifnot HasSpecifiedAction}}
            Usage - {{UsageSummary Cyan!}}
            !{{ifnot}}
            {{if HasGlobalArguments}}
            {{if HasActions}}Global options!{{if}}{{ifnot HasActions}}Options!{{ifnot}}:
            
            {{table Arguments DefaultAlias&gt;Option Description !}}
            !{{if}}
            {{if HasActions}}
            {{if HasSpecifiedAction}}
            
            Usage - {{ExeName Cyan!}} {{SpecifiedAction.UsageSummary Cyan!}}
            
            {{if SpecifiedAction.HasArguments }}
            {{SpecifiedAction.DefaultAlias!}} Options:
            {{table SpecifiedAction.Arguments DefaultAlias&gt;Name Description !}}
             [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:PowerArgs.Resources.QueryTemplate">
             <summary>
               Looks up a localized string similar to using System;
            using System.Linq;
            using System.Collections.Generic;
            $Usings$
            
            namespace $Namespace$
            {
                public class $Class$
                {
                    public static List&lt;$ReturnType$&gt; $Method$(IEnumerable&lt;$ReturnType$&gt; source)
                    {
                        IEnumerable&lt;$ReturnType$&gt; query = from item in source select item;
            
                        $WhereComment$              query = from item in query where $Where$ select item;
                        $OrderByDescendingComment$  query = query.OrderByDescending($OrderByDescending$);
                [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:PowerArgs.DocumentRendererContext">
            <summary>
            An object that tracks information about document rendering
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.#ctor(System.Object)">
            <summary>
            Creates a render context from a root data object
            </summary>
            <param name="rootDataObject">The root data object that will be bound to a template</param>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderDynamicContent(System.String,PowerArgs.DocumentToken)">
            <summary>
            Dynamically renders the given template.
            </summary>
            <param name="dynamicTemplate">The template to render</param>
            <param name="nestedToken">The token in the original document that resulted in dynamic rendering</param>
            <returns>The rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderBody(System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Renders the given tokens, which are generally the body of a replacement expression.
            </summary>
            <param name="body">The tokens to render</param>
            <returns>the rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.EvaluateExpression(System.String)">
            <summary>
            Evaluates the given expression and returns the result.  The expression can refer to a local variable (e.g. 'somevariable'), 
            a path starting from a localVariable (e.g. 'somevariable.SomeProperty.SomeOtherProperty'), or a path starting from the root
            data object (e.g. if the root was of type 'Person' you could say 'FirstName', assuming the Person type has a property called 'FirstName').
            </summary>
            <param name="expressionText">The expression text</param>
            <returns>The resolved value as a .NET object</returns>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.LocalVariables">
            <summary>
            The current set of local variables that can be referenced by a template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.RootDataObject">
            <summary>
            The root data object that is bound to the document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.DocumentRenderer">
            <summary>
            The object that is currently rendering a document
            </summary>
        </member>
        <member name="T:PowerArgs.TemplateExpression">
            <summary>
            A document expression that can render a named template
            </summary>
        </member>
        <member name="T:PowerArgs.IDocumentExpression">
            <summary>
            An interface that defines a signature for evaluating an expression against a data context to render a ConsoleString.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            The expression should use it's metadata to evaluate itself against the given data context.
            </summary>
            <param name="context">The data context</param>
            <returns>The evaluated ConsoleString.</returns>
        </member>
        <member name="M:PowerArgs.TemplateExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new template expression given an id token and a data evaluation token.
            </summary>
            <param name="idToken">A token containing the id of the template to render</param>
            <param name="evalToken">A token containing an expression to be evaluated.  The result of the evaluation will be
            used as the root data object to be bound to the named template.</param>
        </member>
        <member name="M:PowerArgs.TemplateExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Finds the matching template from the data context, evaluates the data expression, then renders
            the template against the data.  The rendered document is inserted into the parent document.
            </summary>
            <param name="context">The data context used to find the named template and to evaluate the data expression</param>
            <returns>The rendered child document to be inserted into the parent document</returns>
        </member>
        <member name="P:PowerArgs.TemplateExpression.IdToken">
            <summary>
            A token containing the id of the template to render
            </summary>
        </member>
        <member name="P:PowerArgs.TemplateExpression.EvalToken">
            <summary>
            A token containing an expression to be evaluated.  The result of the evaluation
            will be used as the root data object to be bound to the named template.
            </summary>
        </member>
        <member name="T:PowerArgs.TemplateExpressionProvider">
            <summary>
            A provider that can create a template expression from a replacement token and parameters.
            </summary>
        </member>
        <member name="T:PowerArgs.IDocumentExpressionProvider">
            <summary>
            An object that can take a replacement key, a set of parameters, an optional body, and transform it into a document expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Transforms a replacement key, parameters, and body into a document expression
            </summary>
            <param name="replacementKeyToken">The replacement key (e.g. 'each' in {{each foo in bar }})</param>
            <param name="parameters">The parameters that were provided in the replacement tag.  Whitespace has not been removed for you.</param>
            <param name="body">The contents of the doucment that are inside of the replacement tag</param>
            <returns>The formal expression that can be evaluated into text</returns>
        </member>
        <member name="M:PowerArgs.TemplateExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a template expression given a replacement token and parameters.
            </summary>
            <param name="replacementKeyToken">The token whose value should be 'template'</param>
            <param name="parameters">There should be 2 parameters.  One representing the name of the template to render and one representing the data to bind to the template.</param>
            <param name="body">Should be empty.  Template expressions do not support a body.</param>
            <returns>a template expression</returns>
        </member>
        <member name="T:PowerArgs.TableExpression">
            <summary>
            A document expression that can be used to render a table that is specifically formatted to display
            in a console window.
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a new table expression given a collection evaluation expression and a list of column tokens
            </summary>
            <param name="evalToken">A token containing an expression that should evaluate to an IEnumerable</param>
            <param name="columns">A list of tokens containing the names of columns to display in the table</param>
        </member>
        <member name="M:PowerArgs.TableExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the table given a data context
            </summary>
            <param name="context">the data context</param>
            <returns>the console friendly table, as a ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.TableExpression.FormatAsTable(System.Collections.Generic.List{PowerArgs.ConsoleString},System.Collections.Generic.List{System.Collections.Generic.List{PowerArgs.ConsoleString}},System.String)">
            <summary>
            Formats the given column headers and rows as a table.
            </summary>
            <param name="columns">The column headers</param>
            <param name="rows">The row data</param>
            <param name="rowPrefix">A string to prepend to each row.  This can be used to indent a table.</param>
            <returns>The rendered table as a ConsoleString</returns>
        </member>
        <member name="P:PowerArgs.TableExpression.EvalToken">
            <summary>
            The token representing the expression to evaluate.  The expression is expected to resolve to
            an IEnumerable.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.Columns">
            <summary>
            The tokens that represent the columns to display.  Each value is expected to be a property name.  Optionally, you can
            override the display name by appending '>NewDisplayName' to the value.  For example, if there was a property called 'TheName'
            and you wanted it to display as 'Name' then the value of the column token would be 'TheName>Name'.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowPossibleValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then properties that are enums 
            will have their values inserted into the table.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowDefaultValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then the properties that have a default 
            value will have that inserted into the table
            </summary>
        </member>
        <member name="T:PowerArgs.TableExpressionProvider">
            <summary>
            A provider that can create a table expression given a replacement token and parameters.
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a table expression from the given document info.
            </summary>
            <param name="replacementKeyToken">The token that should contain a value of 'table'</param>
            <param name="parameters">Replacement parameters that should be column names and optional properties</param>
            <param name="body">Should be empty.  Table expressions don't support bodies</param>
            <returns>The created document expression</returns>
        </member>
        <member name="T:PowerArgs.VarExpression">
            <summary>
            An expression that indicates the beginning of a local variable's scope
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new variable expression given a name and value expression
            </summary>
            <param name="name">A token containing the name of the local variable to initialize</param>
            <param name="value">A token containing an expression that should resolve to the initial value of the variable</param>
        </member>
        <member name="M:PowerArgs.VarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Always results in an empty string, but initializes the local value in the data context
            </summary>
            <param name="context">The data context used to store the newly initialized variable</param>
            <returns>an empty string</returns>
        </member>
        <member name="P:PowerArgs.VarExpression.NameToken">
            <summary>
            A token containing the name of the local variable to initialize
            </summary>
        </member>
        <member name="P:PowerArgs.VarExpression.ValueToken">
            <summary>
            A token containing an expression that should resolve to the initial value of the variable
            </summary>
        </member>
        <member name="T:PowerArgs.ClearVarExpression">
            <summary>
            An expression that indicates the end of a local variable's scope
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a new clear variable expression given a variable name
            </summary>
            <param name="name">A token containing the name of the variable whose scope is ending</param>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Removes the named variable from the context's local variable set
            </summary>
            <param name="context">the context that should contain the local variable to remove</param>
            <returns>an empty string</returns>
        </member>
        <member name="P:PowerArgs.ClearVarExpression.NameToken">
            <summary>
            A token containing the name of the variable whose scope is ending
            </summary>
        </member>
        <member name="T:PowerArgs.VarExpressionProvider">
            <summary>
            A provider that can create a variable expression
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a variable expression given replacement info
            </summary>
            <param name="replacementKeyToken">The replacement key token that should have a value of 'var'</param>
            <param name="parameters">There should be 2 parameters.  The name of the variable and the initial value.</param>
            <param name="body">There should be no body</param>
            <returns>A variable expression</returns>
        </member>
        <member name="T:PowerArgs.ClearVarExpressionProvider">
            <summary>
            A provider that can create an expression to clear a local variable
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a clear variable expression given replacement info
            </summary>
            <param name="replacementKeyToken">The replacement key token that should have a value of 'clearvar'</param>
            <param name="parameters">There should be 1 parameter, the name of the variable.</param>
            <param name="body">There should be no body</param>
            <returns>a clear variable expression</returns>
        </member>
        <member name="T:PowerArgs.EvalExpression">
            <summary>
            The core expression that knows how to evaluate C# object expressions like property navigation, including indexed properties.
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates an eval expression given a token that represents the expression to evaluate
            </summary>
            <param name="evalToken">The token containing the expression to evaluate</param>
        </member>
        <member name="M:PowerArgs.EvalExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the evaluation expression against a data context, optionally setting the console color if the expression contains those parameters
            </summary>
            <param name="context">The datta context to evaluate against</param>
            <returns>The result of the evaluation as a ConsoleString</returns>
        </member>
        <member name="P:PowerArgs.EvalExpression.EvalToken">
            <summary>
            Gets the evaluation token that will be evaluated against a data context
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.ForegroundColorToken">
            <summary>
            The optional foreground color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BackgroundColorToken">
            <summary>
            The optional background color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.FG">
            <summary>
            Gets the ConsoleColor that matches the provided foreground color token, if it was provided.
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BG">
            <summary>
            Gets the ConsoleColor that matches the provided background color token, if it was provided.
            </summary>
        </member>
        <member name="T:PowerArgs.EvalExpressionProvider">
            <summary>
            The provider that can create an eval expression from template replacement info
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates an eval expression given template replacement info
            </summary>
            <param name="replacementKeyToken">The replacement key token which in this case is the evaluation expression</param>
            <param name="parameters">Optional parameters for foreground and background colors.  The values should be valid ConsoleColor values.</param>
            <param name="body">Should be empty.  Eval expressions don't support bodies.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.EachExpression">
            <summary>
            An expression used to expand a portion of a document template for each element in a collection
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a new each expression given an iteration variable name, a collection expression, and a body.
            </summary>
            <param name="iterationVariable">The name to assign to ther variable representing the current element in the template</param>
            <param name="collectionExpression">The expression used to determine the collection to enumerate</param>
            <param name="body">The body of the each loop</param>
        </member>
        <member name="M:PowerArgs.EachExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the each loop
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The rendered contents of the each loop</returns>
        </member>
        <member name="P:PowerArgs.EachExpression.IterationVariableNameToken">
            <summary>
            Gets the token in the document that represents the iteration variable name (e.g. 'element' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.CollectionVariableExpressionToken">
            <summary>
            Gets the token in the document that represents the collection evaluation expression (e.g. 'collection' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.Body">
            <summary>
            Gets the body of the each expression.  This body will be evaluated once fore each element in the collection.
            </summary>
        </member>
        <member name="T:PowerArgs.EachExpressionProvider">
            <summary>
            A class that can take in document replacement info and convert it into a document expression that represents an each loop.
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Takes in document replacement info and converts it into a document expression that represents an each loop.
            </summary>
            <param name="replacementKeyToken">The token that is expected to have a value of 'each'</param>
            <param name="parameters">The parameters which should follow the format ITERATION_VARIABLE_NAME in COLLECTION_EXPRESSION</param>
            <param name="body">The body of the each loop</param>
            <returns>The parsed each expression</returns>
        </member>
        <member name="T:PowerArgs.ConsoleColorStackElement">
            <summary>
            An element that can be used to track the state of the renderer's colors as expressions are being evaluated
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.FG">
            <summary>
            An optional foreground color value
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.BG">
            <summary>
            An optional background color value
            </summary>
        </member>
        <member name="T:PowerArgs.LocalVariableSet">
            <summary>
            A class that lets the document renderer track local variable state as expressions are being evaluated
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.#ctor">
            <summary>
            Creates a new local variable set
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PushConsoleColors(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Sets the current console color variables to the given values, pushing the existing values onto a stack
            </summary>
            <param name="fg">The optional foreground color to set</param>
            <param name="bg">The optional background color to set</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PopConsoleColors">
            <summary>
            Pops the latest console colors off of the stack and sets them as the current colors to use.
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Add(PowerArgs.DocumentToken,System.Object)">
            <summary>
            Adds a new local variable.  This will throw if there's already a variable defined with the given identifier
            </summary>
            <param name="variableToken">The token containing the identifier of the variable name</param>
            <param name="value">The initial value of the local variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Force(System.String,System.Object)">
            <summary>
            Forefully sets the value of a local value, regardless of whether or not that variable is already defined.
            </summary>
            <param name="variableName">The name of the variable</param>
            <param name="value">The value of the variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Remove(PowerArgs.DocumentToken)">
            <summary>
            Removes a local variable.  This will throw if there is no variable with the given name
            </summary>
            <param name="variableToken">The token containing the identifier of the variable to remove</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.ForceClear(System.String)">
            <summary>
            Tries to remove a variable, and does not throw if the variable is not defined.
            </summary>
            <param name="variableName">The name of the variable to clear</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.IsDefined(System.String)">
            <summary>
            Determines if the given variable is defined
            </summary>
            <param name="variableName">The name to check</param>
            <returns>True if the variable is defined, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.TryParseLocalVariable(System.String,System.Object@,System.String@)">
            <summary>
            Tries to parse a local variable from an expression.  If successful the expression is evaluated then the local variable is returned via an out variable.  
            If there was more to the expression, a property navigation for example, then that is also passed to the caller via an out variable.
            </summary>
            <param name="expression">The expression that may refer to a local variable</param>
            <param name="result">The local variable that is set if a local variable was matched</param>
            <param name="restOfExpression">The rest of the expression that came after the local variable identifier</param>
            <returns>True if a local variable was parsed, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentForegroundColor">
            <summary>
            Gets the current foreground color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentBackgroundColor">
            <summary>
            Gets the current background color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.Item(System.String)">
            <summary>
            Gets the value of a local variable given an identifier
            </summary>
            <param name="variableName">the name of the variable to lookup</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.DynamicExpressionProviderAttribute">
            <summary>
            An attribute that can be added to a class that implements IDocumentExpressionProvider.  This attributes indicates that the provider can be
            dynamically registered.
            </summary>
        </member>
        <member name="M:PowerArgs.DynamicExpressionProviderAttribute.#ctor(System.String)">
            <summary>
            Creates a new DynamicExpressionProviderAttribute given a key
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:PowerArgs.DynamicExpressionProviderAttribute.Key">
            <summary>
            The replacement key (e.g. 'each' in {{each foo in bar }}) to use when the given provider is registered
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentExpressionParser">
            <summary>
            A class that can parse a collection of document tokens into a collection of expressions
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.#ctor">
            <summary>
            Creates a new document expression parser and registers the built in expression provider types.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterDynamicReplacementExpressionProviders(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Searches the given assembly for IDocumentExpressionProvider types that have the DynamicExpressionProviderAttribute attribute and registers those providers
            with this parser.  The type needs to have a default constructor.
            </summary>
            <param name="target">The assembly to search</param>
            <param name="allowOverrideExistingKeys">If true, providers with keys that are already exist with override the existing providers.  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterReplacementExpressionProvider(System.String,PowerArgs.IDocumentExpressionProvider,System.Boolean)">
            <summary>
            Manually registers the given expression provider using the given key.  
            </summary>
            <param name="replacementKey">The unique key for the replacement provider (e.g. 'each' in {{each foo in bar}}</param>
            <param name="provider">The provider to register</param>
            <param name="allowOverrideExistingKeys">If true, allow this provider to replace an existing provider registered with the same key .  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.UnregisterReplacementExpressionProvider(System.String)">
            <summary>
            Unregisters the expression provider with the given key
            </summary>
            <param name="replacementKey">The key of the provider to unregister</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.Parse(System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Parses the given tokens into document expressions that can then be evaluated against a data context.
            </summary>
            <param name="tokens">The tokens to parse</param>
            <returns>a list of document expressions</returns>
        </member>
        <member name="P:PowerArgs.DocumentExpressionParser.RegisteredReplacementExpressionProviderKeys">
            <summary>
            Gets a list of registered expression provider keys
            </summary>
        </member>
        <member name="T:PowerArgs.PlainTextDocumentExpression">
            <summary>
            A document expression that represents plain text with no replacements or custom logic
            </summary>
        </member>
        <member name="F:PowerArgs.PlainTextDocumentExpression.tokens">
            <summary>
            The plain text tokens
            </summary>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a plain text document expression given a list of tokens
            </summary>
            <param name="tokens">A list of plain text tokens to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a plain text document expression given a single plain text token
            </summary>
            <param name="singleToken">A single plain text token to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the tokens in the expression, using the ambient foreground and background colors if they are set.
            </summary>
            <param name="context">The data context to use for evaluation</param>
            <returns>The rendered plain text</returns>
        </member>
        <member name="T:PowerArgs.TokenReader`1">
            <summary>
            A class that makes it easy to read through a list of tokens
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PowerArgs.TokenReader`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Creates a token reader given a list of tokens
            </summary>
            <param name="tokens">The list of tokens to read through</param>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Advance(System.Boolean)">
            <summary>
            Advances the reader to the next token
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>the next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Peek(System.Boolean)">
            <summary>
            Gets the next token in the list without actually advancing the reader
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>The next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryAdvance(`0@,System.Boolean)">
            <summary>
            Advances the reader to the next token if one exists.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader advanced, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.CanAdvance(System.Boolean)">
            <summary>
            Determines if the reader can advance
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if there is another token to read, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryPeek(`0@,System.Int32@,System.Int32,System.Boolean)">
            <summary>
            Reads the next token without advancing if one is available.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="lastPeekIndex">The out variable to store the index of the peeked token in the token list</param>
            <param name="lookAhead">How far to peek ahead, by default 1</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader peeked at a value, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString">
            <summary>
            Gets all the tokens in the list concatenated into a single string, including whitespace
            </summary>
            <returns>all the tokens in the list concatenated into a single string, including whitespace</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString(System.Boolean)">
            <summary>
            Gets all the tokens in the list concatenated into a single string, optionally excluding whitespace
            </summary>
            <param name="skipWhitespace">If true, whitespace tokens will not be included in the output.  Tokens that have
            whitespace and non whitespace characters will always be included</param>
            <returns>all the tokens in the list concatenated into a single string, with whitespace tokens optionally excluded</returns>
        </member>
        <member name="T:PowerArgs.DocumentTokenType">
            <summary>
            An enum defining the types of tokens that can appear in a templated document
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementKey">
            <summary>
            Indicates the Key of a replacement tag.  Example: 'each' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementParameter">
            <summary>
            Indicates a parameter in a replacement tag.  Example: 'foo', 'in', and 'bar' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.PlainText">
            <summary>
            Text that is not transformed by the document renderer
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginReplacementSegment">
            <summary>
            Indicates the beginning of a replacement tag '{{'.
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.EndReplacementSegment">
            <summary>
            Indicates the end of a replacement segment '}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginTerminateReplacementSegment">
            <summary>
            Indicates the beginning of a termination segment '!{{'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.QuickTerminateReplacementSegment">
            <summary>
            Indicates that a replacement segment has no body and this is the end of the segment '!}}'
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentToken">
            <summary>
            A class that represents a token in a templated document
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new document token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">the zero based character index of this token in a document template</param>
            <param name="line">The line number of this token in a document template (starts at 1)</param>
            <param name="col">The column number of this token in a document template (starts at 1)</param>
        </member>
        <member name="M:PowerArgs.DocumentToken.GetTokenTypeValue(PowerArgs.DocumentTokenType)">
            <summary>
            Gets the constant string value of a given token type.  This method will throw an exception if the
            type provided does not map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <returns>The literal string value expected of a token of the given type</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryGetTokenTypeValue(PowerArgs.DocumentTokenType,System.String@)">
            <summary>
            Tries to get the constant string value of a given token type.  This method will return false for types that don't
            map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <param name="val">The literal string value expected of a token of the given type</param>
            <returns>true if 'val' was populated, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryParseDocumentTokenType(System.String,PowerArgs.DocumentTokenType@)">
            <summary>
            Tries to parse a literal string value to a well known document token type.
            </summary>
            <param name="stringVal">The value to try to parse</param>
            <param name="type">The reference to populate if parsing is successful</param>
            <returns>True if the string could be successfully mapped to a DocumentTokenType, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.Tokenize(System.String,System.String)">
            <summary>
            Tokenizes the given text into a list of DocumentToken objects.
            </summary>
            <param name="text">The text to tokenize</param>
            <param name="sourceLocation">A string describing the source of the text.  This could be a text file path or some other identifier.</param>
            <returns>A list of tokens</returns>
        </member>
        <member name="P:PowerArgs.DocumentToken.TokenType">
            <summary>
            The type of this token
            </summary>
        </member>
        <member name="T:PowerArgs.IfExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is true
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a new if expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to true</param>
        </member>
        <member name="M:PowerArgs.IfExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is true.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was true, an empty string otherwise</returns>
        </member>
        <member name="P:PowerArgs.IfExpression.IfExpressionToken">
            <summary>
            The token representing the conditional expression.  
            </summary>
        </member>
        <member name="P:PowerArgs.IfExpression.Body">
            <summary>
            The contents of the expression to render only if the condition is true
            </summary>
        </member>
        <member name="T:PowerArgs.IfNotExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is not true
            </summary>
        </member>
        <member name="M:PowerArgs.IfNotExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a new ifnot expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to false</param>
        </member>
        <member name="M:PowerArgs.IfNotExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is false.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was false, an empty string otherwise</returns>
        </member>
        <member name="T:PowerArgs.IfExpressionProvider">
            <summary>
            An expression provider that can provide either an If expresison or an IfNot expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.#ctor(System.Boolean)">
            <summary>
            Creates a new provider, indicating whether or not this provider should provide if or ifnot expressions.
            </summary>
            <param name="not">If true, this provider will provide if expressions, otherwise it will provide ifnot expressions</param>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.CreateExpression(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates either an if or an ifnot expression, based on its configuration, using the given document info.
            </summary>
            <param name="replacementKeyToken">The replacement key token whose value is either 'if' or 'ifnot'</param>
            <param name="parameters">There should be no parameters to an if or ifnot expression</param>
            <param name="body">The body which will be conditionally rendered.</param>
            <returns>The expression, either an if or an ifnot expression</returns>
        </member>
        <member name="T:PowerArgs.DocumentRenderException">
            <summary>
            An exception that is thrown while trying to render a templated document
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentToken)">
            <summary>
            Creates an exception given a message and the offending token
            </summary>
            <param name="msg">The exception message</param>
            <param name="offendingToken">The offending token</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentRenderException.NoTokenReason)">
            <summary>
            Creates an exception given a message and a reason why no token was provided
            </summary>
            <param name="msg">The exception message</param>
            <param name="reason">The reason why no token was provided</param>
        </member>
        <member name="T:PowerArgs.DocumentRenderException.NoTokenReason">
            <summary>
            A reason why a token was not provided when creating this exception
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentRenderException.NoTokenReason.EndOfString">
            <summary>
            Indicates that there is no token specified because there was an unexpected end of string.
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentTemplateInfo">
            <summary>
            A class that describes a document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.Value">
            <summary>
            The template text value
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.SourceLocation">
            <summary>
            The template's source location.  This is usually a file location, but it does not have to be.
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentRenderer">
            <summary>
            A class used to render template documents.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.#ctor">
            <summary>
            Creates a new DocumentRenderer.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(PowerArgs.DocumentTemplateInfo,System.Object)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(System.String,System.Object,System.String)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <param name="sourceFileLocation">The source of the template, used when reporting back errors</param>
            <returns>The rendered document</returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.RegisterTemplate(System.String,PowerArgs.DocumentTemplateInfo)">
            <summary>
            Register a named tamplate that can be accessed by other templates
            </summary>
            <param name="name">The unique name of the template</param>
            <param name="info">The template info</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.UnregisterTemplate(System.String)">
            <summary>
            Unregister a named template.
            </summary>
            <param name="name">The name of the template to unregister</param>
        </member>
        <member name="P:PowerArgs.DocumentRenderer.ExpressionParser">
            <summary>
            Gets the underlying expression parser
            </summary>
        </member>
        <member name="T:PowerArgs.ObjectPathTokenType">
            <summary>
            An enum used to add type metadata to object path expression tokens
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerOpen">
            <summary>
            Indicates the start of an index navigation for objects like arrays, lists, and dictionaries.  '['
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerClose">
            <summary>
            Indicates the end of an index navigation for objects like arrays, lists, and dictionaries. ']'
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.NavigationElement">
            <summary>
            Indicates a property navigation for an object.
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Identifier">
            <summary>
            Indicates a property identifier
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Whitespace">
            <summary>
            Indicates whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.StringLiteral">
            <summary>
            Indicates a string literal inside of double quotes
            </summary>
        </member>
        <member name="T:PowerArgs.ObjectPathToken">
            <summary>
            A token that is a part of an object path expression string
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an object path token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">The start index of the token in the source string</param>
            <param name="line">The line number that this token is on</param>
            <param name="col">The column within the line that this token is on</param>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.TokenFactoryImpl(PowerArgs.Token,System.Collections.Generic.List{PowerArgs.ObjectPathToken})">
            <summary>
            A method that can determine which type of token the given value is
            </summary>
            <param name="token">The token to classify</param>
            <param name="previous">Previously classified tokens in the source string</param>
            <returns>The classified token</returns>
        </member>
        <member name="P:PowerArgs.ObjectPathToken.TokenType">
            <summary>
            Gets the type of token
            </summary>
        </member>
        <member name="T:PowerArgs.ObjectPathExpression">
            <summary>
            An object that represents navigation into an object properties or indexed elements
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.IObjectPathElement})">
            <summary>
            Create a path expression given a collection of path elements
            </summary>
            <param name="elements">The path elements</param>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Parse(System.String)">
            <summary>
            Parses an object path expression from a string.
            </summary>
            <param name="expression">The expression text to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Evaluate(System.Object)">
            <summary>
            Evaluates the expression and returns the value
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>The result of the evaluation</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.EvaluateAndTrace(System.Object)">
            <summary>
            Evaluates the expression, returning the object that corresponds to each element in the path.
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>A list of object where each object corresponds to an element in the path</returns>
        </member>
        <member name="P:PowerArgs.ObjectPathExpression.Elements">
            <summary>
            The path elements for this expression
            </summary>
        </member>
        <member name="T:PowerArgs.IObjectPathElement">
            <summary>
            An object that represents a path element
            </summary>
        </member>
        <member name="T:PowerArgs.PropertyPathElement">
            <summary>
            A path element that represents an object's property
            </summary>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.#ctor(System.String)">
            <summary>
            Creates a property path element given a property name
            </summary>
            <param name="propertyName">the name of the property</param>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.ToString">
            <summary>
            Returns the property name
            </summary>
            <returns>the property name</returns>
        </member>
        <member name="P:PowerArgs.PropertyPathElement.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="T:PowerArgs.IndexerPathElement">
            <summary>
            A path element that represents an index navigation
            </summary>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.#ctor(System.Object)">
            <summary>
            Creates an indexer element given an indexer value
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.FindMatchingProperty(System.Object)">
            <summary>
            Finds the matching property info that represents an indexer property (do not use for strings or arrays).
            </summary>
            <param name="target">The object to search</param>
            <returns>The matching property</returns>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.ToString">
            <summary>
            returns '[' + the index value + ']'
            </summary>
            <returns>'[' + the index value + ']'</returns>
        </member>
        <member name="P:PowerArgs.IndexerPathElement.Index">
            <summary>
            The indexer value, either a literal string or an integer
            </summary>
        </member>
        <member name="T:PowerArgs.TokenizerException">
            <summary>
            An exception that will be thrown if there was an error while tokenizing a string.
            </summary>
        </member>
        <member name="M:PowerArgs.TokenizerException.#ctor(System.String)">
            <summary>
            Creates a new tokenizer exception given a message
            </summary>
            <param name="message">The exception message</param>
        </member>
        <member name="T:PowerArgs.WhitespaceBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndInclude">
            <summary>
            Treats whitespace as a delimiter and includes the whitespace tokens in the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndExclude">
            <summary>
            Treats whitespace as a delimiter, but excludes the whitespace tokens from the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.Include">
            <summary>
            Includes whitespace in the output and does not treat it as a delimiter
            </summary>
        </member>
        <member name="T:PowerArgs.DoubleQuoteBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle double quotes
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.NoSpecialHandling">
            <summary>
            No special handling.  Double quotes will be treated like any normal character.  You can include the double quote in the delimiters list.
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.IncludeQuotedTokensAsStringLiterals">
            <summary>
            Treat values within double quotes as string literals.
            </summary>
        </member>
        <member name="T:PowerArgs.Tokenizer`1">
            <summary>
            A general purpose string tokenizer
            </summary>
            <typeparam name="T">The type of tokens that this tokenizer should output</typeparam>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.#ctor">
            <summary>
            Creates a new tokenizer
            </summary>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.Tokenize(System.String)">
            <summary>
            Tokenizes the given string into a list of tokens
            </summary>
            <param name="input">The string to tokenize</param>
            <returns>The list of tokens</returns>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.Delimiters">
            <summary>
            strings to treat as delimiters.  Delimiters with longer lengths will take preference over
            those with shorter lengths.  For example if you add delimiters '{{' and '{' and the document
            contains '{{Hello' then you'll get 2 tokens, first '{{', then 'hello'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.TokenFactory">
            <summary>
            A function that given a plain token can transform it into the strongly typed token
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.WhitespaceBehavior">
            <summary>
            Gets or sets the option that describes how whitespace should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.DoubleQuoteBehavior">
            <summary>
            Gets or sets the option that describes how double quotes should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.EscapeSequenceIndicator">
            <summary>
            An escape sequence identifier.  By default it is '\'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.SourceFileLocation">
            <summary>
            A string that describes the source location for the given document
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHiddenFromUsage">
            <summary>
            Use this attribute to hide an argument from the usage output.  Users will still be able to provide
            the argument, but it will be undocumented.  This is useful if you want to invlude some secret commands
            or diagnostic commands.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHiddenFromUsage.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            Sets the ignore flag on the info context so the usage generator skips this argument.
            </summary>
            <param name="info">The info about the argument we're hiding</param>
        </member>
        <member name="T:PowerArgs.ArgHook">
            <summary>
            An abstract class that you can implement if you want to hook into various parts of the
            parsing pipeline.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the parser ever looks at the command line.  You can do some preprocessing of the 
            raw string arguments here.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after parsing is complete, but before any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called if CancelAllProcessing() is called on a HookContext object.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeParsePriority">
            <summary>
            The priority of the BeforeParse hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertiesPriority">
            <summary>
            The priority of the BeforePopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertyPriority">
            <summary>
            The priority of the BeforePopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertyPriority">
            <summary>
            The priority of the AfterPopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertiesPriority">
            <summary>
            The priority of the AfterPopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeInvokePriority">
            <summary>
            The priority of the BeforeInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterInvokePriority">
            <summary>
            The priority of the AfterInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterCancelPriority">
            <summary>
            The priority of the AfterCancel hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHook.HookContext">
            <summary>
            Context that is passed to your hook.  Different parts of the context will be available
            depending on which part of the pipeline you're hooking into.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.CmdLineArgs">
            <summary>
            The command line arguments that were passed to the Args class.  This is always available and you
            can modify it in the BeforeParse hook at your own risk.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.ArgumentValue">
            <summary>
            The string value that was specified for the current argument.  This will align with the value of ArgHook.CurrentArgument.
            
            This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.RevivedProperty">
            <summary>
            This is the value of the current property after it has been converted into its proper .NET type.  It is only available
            to the AfterPopulateProperty hook.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.GetProperty``1(System.String)">
            <summary>
            Get a value from the context's property bag.
            </summary>
            <typeparam name="T">The type of value you are expecting</typeparam>
            <param name="key">The key for the property you want to get</param>
            <returns>The value or default(T) if no value was found.</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.SetProperty``1(System.String,``0)">
            <summary>
            Set a value in the context's property bag.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key">The key for the property you want to set</param>
            <param name="value">The value of the property to set</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.HasProperty(System.String)">
            <summary>
            Returns true if the context has a value for the given property.
            </summary>
            <param name="key">The key to check</param>
            <returns>true if the context has a value for the given property, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.ClearProperty(System.String)">
            <summary>
            Clear a value in the context's property bag.
            </summary>
            <param name="key">The key for the property you want to clear.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.CancelAllProcessing">
            <summary>
            Stops all argument processing, hooks, and action invocation as soon as is feasable.  You
            can implement an ArgHook that receives an event when this is called.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Current">
            <summary>
            Gets the context for the current parse operation happening on the current thread or
            null if no parse is happening on the current thread.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Property">
            <summary>
            The current property being operating on.  This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.CurrentArgument">
            <summary>
            The current argument being operating on. 
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.SpecifiedAction">
            <summary>
            Gets the action that was specified on the command line or null if no action was specified or if the definition exposes no actions.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Args">
            <summary>
            This is the instance of your argument class.  The amount that it is populated will depend on how far along in the pipeline
            the parser is.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Definition">
            <summary>
            The definition that's being used throughout the parsing process
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.ParserData">
            <summary>
            The raw parser data.  This is not available to the BeforeParse hook.  It may be useful for you to look at, but you should rarely have to change the values.  
            Modify the content of this at your own risk.
            </summary>
        </member>
        <member name="T:PowerArgs.DefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new DefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before the property is revived and validated, if the user didn't specify a value, 
            then substitue the default value.
            
            </summary>
            <param name="Context"></param>
        </member>
        <member name="P:PowerArgs.DefaultValueAttribute.Value">
            <summary>
            The default value that was specified on the attribute.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
        </member>
        <member name="T:PowerArgs.HelpHook">
            <summary>
            A hook that lets you turn a boolean property into a command line switch that short circuits processing and displays help.
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.#ctor">
            <summary>
            Creates a new help hook instance
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Makes sure the target is a boolean
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This gets called after the target property is populated.  It cancels processing.
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            Writes the help as long as WriteHelp is true
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="P:PowerArgs.HelpHook.EXEName">
            <summary>
            Optional.  The name of the EXE that is displayed by the help.  By default it will use the entry assembly exe name.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowTypeColumn">
            <summary>
            Optionally show the TYPE column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowPositionColumn">
            <summary>
            Optionally show the POSITION column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums).  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.WriteHelp">
            <summary>
            If true (which it is by default) the hook will write the help after the target property is populated.  If false, processing will still stop, but
            the help will not be written (yoy will have to do it yourself).
            </summary>
        </member>
        <member name="E:PowerArgs.HelpHook.UsageWritten">
            <summary>
            An event that fires when the hook writes usage to the console
            </summary>
        </member>
        <member name="T:PowerArgs.StickyArg">
            <summary>
            A useful arg hook that will store the last used value for an argument and repeat it the next time.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor">
            <summary>
            Marks a property as a sticky arg.  Use the default location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor(System.String)">
            <summary>
            Marks a property as a sticky arg.  Use the provided location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the user didn't specify a value on the command line then the StickyArg will try to load the last used
            value.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the given property has a non null value then that value is persisted for the next use.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="T:PowerArgs.IStickyArgPersistenceProvider">
            <summary>
            An interface used to implement custom saving and loading of persistent (sticky) args.
            </summary>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Save(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            This method is called when it is time to save the sticky args.
            </summary>
            <param name="stickyArgs">The names and values of the arguments to save.</param>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Load(System.String)">
            <summary>
            This method is called when it is time to load the sticky args.
            </summary>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
            <returns>The loaded sticky args.</returns>
        </member>
        <member name="T:PowerArgs.StickyArgPersistence">
            <summary>
            An attribute you can put on a type in order to override how StickyArg properties are saved and loaded.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArgPersistence.#ctor(System.Type)">
            <summary>
            Creates a new StickyArgPersistence attribute given the type of the persistence provider.
            </summary>
            <param name="persistenceProviderType">The type that implements IStickyArgPersistenceProvider and defines a default constructor.</param>
        </member>
        <member name="P:PowerArgs.StickyArgPersistence.PersistenceProvider">
            <summary>
            Gets the provider that will be used to save and load sticky args.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionMethod">
            <summary>
            Use this attribute to annotate methods that represent your program's actions.  
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionType">
            <summary>
            Use this attribute if your action implementation methods are defined in a type other than the 
            type being passed to Args.ParseAction() or Args.InvokeAction().
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionType.#ctor(System.Type)">
            <summary>
            Creates a new ArgActionType attribute given the type that contains the action implementation.
            </summary>
            <param name="t">The type that implements your action methods.</param>
        </member>
        <member name="P:PowerArgs.ArgActionType.ActionType">
            <summary>
            The type that implements your action methods.
            </summary>
        </member>
        <member name="T:PowerArgs.NonInteractiveIndicator">
            <summary>
            An attribute that can be specified on a boolean argument to indicate a non interactive session.  
            When used, it sets IsNonInteractive on the current definition.
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.#ctor">
            <summary>
            Creates a new NonInteractiveIndicator attribute
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the current argument is a boolean and it is specified on the command line then
            this hook sets the IsNonInteractive flag on the current argument definition.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:PowerArgs.ArgDescription">
            <summary>
            Use this attribute to describe your argument property.  This will show up in the auto generated
            usage documentation.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDescription.#ctor(System.String)">
            <summary>
            Creates a new ArgDescription attribute.
            </summary>
            <param name="description">A brief description of your argument property.</param>
        </member>
        <member name="P:PowerArgs.ArgDescription.Description">
            <summary>
            A brief description of your argument property.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExample">
            <summary>
            Use this attribute to provide an example of how to use your program.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExample.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgExample class
            </summary>
            <param name="example">The example command line.</param>
            <param name="description">A brief description of what this example does.</param>
        </member>
        <member name="P:PowerArgs.ArgExample.Title">
            <summary>
            An optional title for this example
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Example">
            <summary>
            The example command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Description">
            <summary>
            A brief description of what this example does.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExceptionPolicy">
            <summary>
            Enum used to specify how user errors (ArgExceptions) should be handled by the parser.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.DontHandleExceptions">
            <summary>
            The default, PowerArgs will throw these exceptions for your program to handle.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.StandardExceptionHandling">
            <summary>
            PowerArgs will print the user friendly error message as well as the auto-generated usage documentation
            for the program.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExceptionBehavior">
            <summary>
            Use this attrbiute to opt into standard error handling of user input errors.  
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExceptionBehavior.#ctor(PowerArgs.ArgExceptionPolicy)">
            <summary>
            Creates a new ArgExceptionBehavior attributes with the given policy.
            </summary>
            <param name="policy">The policy to use, defaults to DontHandleExceptions.</param>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.Policy">
            <summary>
            The policy to use, defaults to DontHandleExceptions.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowTypeColumn">
            <summary>
            Optionally show the TYPE column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowPositionColumn">
            <summary>
            Optionally show the POSITION column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums).  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ExeName">
            <summary>
            Optionally override the ExeName.  You need to do this in unit tests.  In a real console app the
            value will be detected automatically if you leave this as null.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.UsageTemplateFile">
            <summary>
            The usage template to use to display usage information.  You can leave this null if you want to use the default template.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreAttribute">
            <summary>
            Use this attribute if you want PowerArgs to ignore a property completely.
            </summary>
        </member>
        <member name="T:PowerArgs.IArgumentOrActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments or CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreCase">
            <summary>
            Use this argument on your class, property, or action method to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgIgnoreCase.#ctor(System.Boolean)">
            <summary>
            Create a new ArgIgnoreCase attribute.
            </summary>
            <param name="ignore">Whether or not to ignore case</param>
        </member>
        <member name="P:PowerArgs.ArgIgnoreCase.IgnoreCase">
            <summary>
            Flag to set whether or not case is ignored.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgEnforceCase">
            <summary>
            Use this argument on your class or property to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgEnforceCase.#ctor">
            <summary>
            Create a new ArgEnforceCase attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgPosition">
            <summary>
            Use this attribute if you want users to be able to specify an argument without specifying the name, 
            but rather by it's position on the command line.  All positioned arguments must come before any named arguments.
            Zero '0' represents the first position.  If you are using the Action framework then subcommands must start at
            position 1.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgPosition.#ctor(System.Int32)">
            <summary>
            Creates a new ArgPositionAttribute
            </summary>
            <param name="pos">The expected position of this argument</param>
        </member>
        <member name="P:PowerArgs.ArgPosition.Position">
            <summary>
            The expected position of this argument
            </summary>
        </member>
        <member name="T:PowerArgs.ArgReviverAttribute">
            <summary>
            The attribute used when you want to create an arg reviver. You should put this on public static methods 
            that take 2 string parameters (the first represents the name of the property, the second represents the string value
            and the return type is the type that you are reviving (or converting) the string into.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcutPolicy">
            <summary>
            An enum to represent argument shortcut policies
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.Default">
            <summary>
            No special behavior.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.NoShortcut">
            <summary>
            Pass this value to the ArgShortcut attribute's constructor to indicate that the given property
            does not support a shortcut.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.ShortcutsOnly">
            <summary>
            This indicates that the .NET property named should not be used as an indicator.  Instead,
            only the values in the other ArgShortcut attributes should be used.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcut">
            <summary>
            Use this attribute to override the shortcut that PowerArgs automatically assigns to each property.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(System.String)">
            <summary>
            Creates a new ArgShortcut attribute with a specified value.
            </summary>
            <param name="shortcut">The value of the new shortcut.</param>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(PowerArgs.ArgShortcutPolicy)">
            <summary>
            Creates a new ArgShortcut using the given policy
            </summary>
            <param name="policy"></param>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Shortcut">
            <summary>
            The shortcut for the given property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Policy">
            <summary>
            Get the ShortcutPolicy for this attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgLongForm">
            <summary>
            An attribute used to define long form aliases for argument
            names.  For example, --log-level instead of -log.
            It also supports an alternate syntax for providing the values.
            For example: --log-level=error instead of -log error or /log:error.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgLongForm.#ctor(System.String)">
            <summary>
            Creates a new instance of an ArgLongForm attribute given the shortcut value.
            </summary>
            <param name="value">The shortcut value</param>
        </member>
        <member name="T:PowerArgs.ArgStyle">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.PowerShell">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.SlashColon">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgStyleAttribute">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgStyleAttribute.#ctor(PowerArgs.ArgStyle)">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
            <param name="style">obsolete</param>
        </member>
        <member name="P:PowerArgs.ArgStyleAttribute.Style">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="T:PowerArgs.OmitFromUsageDocs">
            <summary>
            An attribute that, when placed on a property or action method, makes sure that property/action does not appear
            in the output created by the ArgUsage class (the class that auto generates usage documentation).
            </summary>
        </member>
        <member name="M:PowerArgs.OmitFromUsageDocs.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            sets the ignroe flag on the info object
            </summary>
            <param name="info">the context used to modify the usage documentation</param>
        </member>
        <member name="T:PowerArgs.CommandLineAction">
            <summary>
            A class that represents command line actions that users can specify on the command line.  This is useful for programs like git
            where users first specify an action like 'push' and then the remaining arguments are either global or specific to 'push'.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineAction.#ctor(System.Action{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a new command line action given an implementation.
            </summary>
            <param name="actionHandler">The implementation of the action.</param>
        </member>
        <member name="M:PowerArgs.CommandLineAction.ToString">
            <summary>
            Gets a string representation of this action.
            </summary>
            <returns>a string representation of this action</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.Equals(System.Object)">
            <summary>
            Determines if 2 actions are the same based on their source.  
            </summary>
            <param name="obj">The other action</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Aliases">
            <summary>
            The values that the user can specify on the command line to specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Arguments">
            <summary>
            The action specific arguments that are applicable to the end user should they specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummary">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Description">
            <summary>
            The description that will be shown in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Source">
            <summary>
            The method or property that was used to define this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IsSpecifiedAction">
            <summary>
            This will be set by the parser if the parse was successful and this was the action the user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IgnoreCase">
            <summary>
            Indicates whether or not the parser should ignore case when matching a user string with this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.DefaultAlias">
            <summary>
            The first alias or null if there are no aliases.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Metadata">
            <summary>
            The list of metadata that can be used to inject behavior into the action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.ActionMethod">
            <summary>
            The implementation of the action that can be invoked by the parser if the user specifies this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasExamples">
            <summary>
            Returns true if there is at least 1 ArgExample metadata on this action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasArguments">
            <summary>
            Returns true if this action has at least 1 action specific argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Examples">
            <summary>
            Examples that show users how to use this action.
            </summary>
        </member>
        <member name="T:PowerArgs.CommandLineArgument">
            <summary>
            Instances of this class represent a single command line argument that users can specify on the command line.
            Supported syntaxes include:
                -argumentName argumentValue
                /argumentName:argumentValue
                -argumentName                   - If the argument is a boolean it will be true in this case.
                --argumentName=argumentValue    - Only works if you have added an alias that starts with --.
                argumentValue                   - Only works if this argument defines the Position property as >= 0
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            Creates a command line argument of the given type and sets the first default alias.
            </summary>
            <param name="t">The CLR type of the argument</param>
            <param name="defaultAlias">The default name that users will use to specify this argument</param>
            <param name="ignoreCase">If true, the parser will match this argument even if the specifier doesn't match case.  True by default.</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.ToString">
            <summary>
            Gets the string representation of this argument.
            </summary>
            <returns>the string representation of this argument.</returns>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Aliases">
            <summary>
            The values that can be used as specifiers for this argument on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Metadata">
            <summary>
            Metadata that has been injected into this Argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.FriendlyTypeName">
            <summary>
            Gets a friendly type name for this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.ArgumentType">
            <summary>
            The CLR type of this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IgnoreCase">
            <summary>
            Specifies whether or not the parser should ignore case when trying to find a match for this argument on the command line.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Position">
            <summary>
            If this is a positional argument then set this value >= 0 and users can specify a value without specifying an argument alias.  Defaults to -1.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.HasDefaultValue">
            <summary>
            Returns true if a default value has been explicitly registered for this argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultValue">
            <summary>
            The default value for this argument in the event it is optional and the user did not specify it.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.EnumValuesAndDescriptions">
            <summary>
            Only works if the ArgumentType is an enum.  Returns a list where each element is a string containing an
            enum value and optionally its description.  Each enum value is represented in the list.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Description">
            <summary>
            The description for this argument that appears in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IsRequired">
            <summary>
            Gets or sets whether or not this argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Source">
            <summary>
            If this argument was inferred from a type then the source is either a PropertyInfo or a ParameterInfo.  If this argument
            was created manually then this value will be null.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.RevivedValue">
            <summary>
            This property will contain the parsed value of the command line argument if parsing completed successfully.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultAlias">
            <summary>
            The first alias of this argument or null if no aliases are defined.
            </summary>
        </member>
        <member name="T:PowerArgs.CommandLineArgumentsDefinition">
            <summary>
            This is the root class used to define a program's command line arguments.  You can start with an empty definition and 
            programatically add arguments or you can start from a Type that you have defined and have the definition inferred from it.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor">
            <summary>
            Creates an empty command line arguments definition.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor(System.Type)">
            <summary>
            Creates a command line arguments definition and infers things like Arguments, Actions, etc. from the type's metadata.
            </summary>
            <param name="t">The argument scaffold type used to infer the definition</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingAction(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineAction that matches the given key
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first action that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.CreateVariableResolver">
            <summary>
            Gives you an object that you can use to tell if a particular argument was specified on the command line.
            </summary>
            <returns>object that you can use to tell if a particular argument was specified on the command line</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.ToString">
            <summary>
            Gets a basic string representation of the definition.
            </summary>
            <returns>a basic string representation of the definition</returns>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExeName">
            <summary>
            Gets or sets the ExeName for this command line argument definition's program.  If not specified the entry assembly's file name
            is used, without the file extension.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Description">
            <summary>
            Gets the description from ArgDescriptionMetadata if it exists, or empty string if it does not.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasGlobalArguments">
            <summary>
            Returns true if there is at least 1 global argument, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasActions">
            <summary>
            Returns true if there is at least 1 action, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummary">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.IsNonInteractive">
            <summary>
            When set to true, TabCompletion is completely disabled and required fields will ignore the PromptIfMissing flag.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ArgumentScaffoldType">
            <summary>
            The type that was used to generate this definition.  This will only be populated if you use the constructor that takes in a type and the definition is inferred.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Arguments">
            <summary>
            The command line arguments that are global to this definition.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.AllGlobalAndActionArguments">
            <summary>
            Gets all global command line arguments as well as all arguments of any actions in this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Hooks">
            <summary>
            Global hooks that can execute all hook override methods except those that target a particular argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Actions">
            <summary>
            Actions that are defined for this definition.  If you have at least one action then the end user must specify the action as the first argument to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Metadata">
            <summary>
            Arbitrary metadata that has been added to the definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasExamples">
            <summary>
            Returns true if there is at least 1 example registered for this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Examples">
            <summary>
            Examples that show users how to use your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExceptionBehavior">
            <summary>
            Determines how end user errors should be handled by the parser.  By default all exceptions flow through to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.SpecifiedAction">
            <summary>
            If your definition declares actions and has been successfully parsed then this property will be populated
            with the action that the end user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasSpecifiedAction">
            <summary>
            Returns true if this definition has been processed and an action was specified
            </summary>
        </member>
        <member name="T:PowerArgs.Query">
            <summary>
            A hook you can use to easily query a data source.  See an example here: https://github.com/adamabdelhamed/PowerArgs#data-source-queries
            </summary>
        </member>
        <member name="M:PowerArgs.Query.#ctor(System.Type,System.String[])">
            <summary>
            Creates a new query hook given a data source type and optional reference assemblies.
            </summary>
            <param name="dataSourceType">Your data source implementation. he query will create a new instance of this type and use a property that matches the property name of the PowerArgs property this attribute is on in order to get the data.</param>
            <param name="referencedAssemblies">The names (if in the GAC) or full paths to assemblies you would like to include.  We will automatically add dlls in your bin folder.</param>
        </member>
        <member name="M:PowerArgs.Query.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            After PowerArgs does most of its work this hook looks for string properties on the parsed object called Skip, Take, 
            Where, OrderBy, and OrderByDescending.  These properties are used to construct a linq query that is dynamically compiled
            and executed against the provided data source.
            </summary>
            <param name="context">The context used to detect the query parameters.</param>
        </member>
        <member name="P:PowerArgs.Query.DataSourceType">
            <summary>
            Your data source implementation.  The query will create a new instance of this type and use a property
            that matches the property name of the PowerArgs property this attribute is on in order to get the data.
            </summary>
        </member>
        <member name="T:PowerArgs.SecureStringArgument">
            <summary>
            A PowerArgs argument type that can be used to accept user input without that input appearing on the command line.
            It uses secure strings under the hood.
            </summary>
        </member>
        <member name="M:PowerArgs.SecureStringArgument.ConvertToNonsecureString">
            <summary>
            Converts the underlying secure string to a regular string.
            </summary>
            <returns>A normal string representation of the user's input.</returns>
        </member>
        <member name="P:PowerArgs.SecureStringArgument.SecureString">
            <summary>
            The secure string value.  The first time your code accesses this property is when the user will be presented with
            the secure input prompt.
            </summary>
        </member>
        <member name="T:PowerArgs.CycledTabCompletionManager">
            <summary>
            This helper class can be leveraged when implementing custom tab completion logic.  It knows how to cycle through multple
            candidates and support tabbing forward and shift/tabbing backwards.  You just pass values from the tab completion methods
            and then provide an evaluation function that knows how to get the list of possible matches.
            </summary>
        </member>
        <member name="M:PowerArgs.CycledTabCompletionManager.Cycle(System.Boolean,System.String@,System.Func{System.Collections.Generic.List{System.String}},System.String@)">
            <summary>
            Cycles through the candidates provided by the given evaluation function using the arguments passed through from
            the tab completion system.
            </summary>
            <param name="shift">You should pass true if the shift key was pressed during the tab</param>
            <param name="soFar">You should pass through a reference to the soFar value that was sent by the tab completion system</param>
            <param name="evaluation">A function that looks at 'soFar' and determines which values might be a match</param>
            <param name="completion">The completion to populate if the conditions all work out</param>
            <returns>True if completion was populated, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.CycledTabCompletionManager.MinCharsBeforeCyclingBegins">
            <summary>
            If the value of soFar is a string that's less than this value then no completion will be returned.
            </summary>
        </member>
        <member name="T:PowerArgs.GroupedRegexArg">
            <summary>
            An abstract class that lets you create custom argument types that match a regular expression.  The 
            class also makes it easy to extract named groups from the regular expression for use by your application.
            </summary>
        </member>
        <member name="F:PowerArgs.GroupedRegexArg.exactMatch">
            <summary>
            The match that exactly matches the given regular expression
            </summary>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new grouped regular expression argument instance.
            </summary>
            <param name="regex">The regular expression to enforce</param>
            <param name="input">The user input that was provided</param>
            <param name="errorMessage">An error message to show in the case of a non match</param>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.Group(System.String,System.String)">
            <summary>
            A helper function you can use to group a particular regular expression.
            </summary>
            <param name="regex">Your regular expression that you would like to put in a group.</param>
            <param name="groupName">The name of the group that you can use to extract the group value later.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.String)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupName">The name of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.Int32)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupNumber">The index of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.MultiTabCompletionSource">
            <summary>
            An aggregate tab completion source that cycles through it's inner sources looking for matches.
            </summary>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(PowerArgs.ITabCompletionSource[])">
            <summary>
            Create a new MultiTabCompletionSource given an array of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ITabCompletionSource})">
            <summary>
            Create a new MultiTabCompletionSource given an IEnumerable of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented since this type implements ITabCompletionSourceWithContext
            </summary>
            <param name="shift"></param>
            <param name="soFar"></param>
            <param name="completion"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Iterates over the wrapped sources looking for a match
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.SimpleTabCompletionSource">
            <summary>
            A simple tab completion source implementation that looks for matches over a set of pre-determined strings.
            </summary>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new completion source given an enumeration of string candidates
            </summary>
            <param name="candidates"></param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Creates a simple tab completion source given a function used to evaluate the candidates.
            </summary>
            <param name="candidateFunction">The function used to evaluate the completions where the input is a string parameter that represents the incomplete token</param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented since this type implements ITabCompletionSourceWithContext
            </summary>
            <param name="shift"></param>
            <param name="soFar"></param>
            <param name="completion"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Iterates through the candidates to try to find a match.  If there are multiple possible matches it 
            supports cycling through tem as the user continually presses tab.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.SimpleTabCompletionSource.MinCharsBeforeCyclingBegins">
            <summary>
            Require that the user type this number of characters before the source starts cycling through ambiguous matches.  The default is 3.
            </summary>
        </member>
        <member name="T:PowerArgs.USPhoneNumber">
            <summary>
            An example of a custom type that uses regular expressions to extract values from the command line
            and implements an ArgReviver to transform the text input into a complex type.
            This class represents a US phone number.
            </summary>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.#ctor(System.String)">
            <summary>
            Creates a phone number object from a string
            </summary>
            <param name="phoneNumber"></param>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString">
            <summary>
            Gets the default string representation of the phone number in the format '1-(aaa)-bbb-cccc'.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString(System.String)">
            <summary>
            Formats the phone number as a string.  
            </summary>
            <param name="format">Use '{aaa}' for the area code, use {bbb} for the first grouping, and use {cccc} for the second grouping.</param>
            <returns>A formatted phone number string</returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.Revive(System.String,System.String)">
            <summary>
            Custom PowerArgs reviver that converts a string parameter into a custom phone number
            </summary>
            <param name="key">The name of the argument (not used)</param>
            <param name="val">The value specified on the command line</param>
            <returns>A USPhoneNumber object based on the user input</returns>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.AreaCode">
            <summary>
            The three digit area code of the phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.FirstDigits">
            <summary>
            The three digit first segment of the phone number
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.SecondDigits">
            <summary>
            The four digit second segment of the phone number.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionAttribute">
            <summary>
            An attribute that can be placed on an argument property that adds argument aware tab completion for users who press the tab key while
            in the context of the targeted argument.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionAttribute.#ctor(System.Type)">
            <summary>
            Creates a new ArgumentAwareTabCompletionAttribute given a completion source type
            </summary>
            <param name="completionSourceType"></param>
        </member>
        <member name="P:PowerArgs.ArgumentAwareTabCompletionAttribute.CompletionSourceType">
            <summary>
            The tab completion source type that will be used to implement tab completion
            </summary>
        </member>
        <member name="T:PowerArgs.TabCompletion">
            <summary>
            A hook that takes over the command line and provides tab completion for known strings when the user presses
            the tab key.
            </summary>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.String)">
            <summary>
            Creates a new tab completion hook.
            </summary>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.Type,System.String)">
            <summary>
            Creates a new tab completion hook given a custom tab completion implementation.
            </summary>
            <param name="completionSource">A type that implements ITabCompletionSource such as SimpleTabCompletionSource</param>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before PowerArgs parses the args, this hook inspects the command line for the indicator and if found 
            takes over the command line and provides tab completion.
            </summary>
            <param name="context">The context used to inspect the command line arguments.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.ClearHistory">
            <summary>
            Clears all history saved on disk
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.Indicator">
            <summary>
            When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryToSave">
            <summary>
            If this is > 0 then PowerArgs will save this many previous executions of the command line to your application data folder.
            Users can then access the history by pressing arrow up or down from the enhanced command prompt.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryFileName">
            <summary>
            The location of the history file name (AppData/PowerArgs/EXE_NAME.TabCompletionHistory.txt
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.ExeName">
            <summary>
            The name of your program (leave null and PowerArgs will try to detect it automatically)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPL">
            <summary>
            If true, then you must use Args.InvokeAction or Args.InvokeMain instead of Args.Parse.  Your user
            will get an interactive prompt that loops until they specify the REPLExitIndicator.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLExitIndicator">
            <summary>
            The string users can specify in order to exit the REPL (defaults to string.Empty)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLWelcomeMessage">
            <summary>
            The message to display to the user when the REPL starts.  The default is Type a command or '{{Indicator}}' to exit.
            You can customize this message and use {{Indicator}} for the placeholder for your exit indicator.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgCantBeCombinedWith">
            <summary>
            Argument metadata that lets you declare that a particular argument is not allowed if one or more other arguments are specified by the user.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.#ctor(System.String)">
            <summary>
            Creates a new ArgCantBeCombinedWith hook given an expression. This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            If the expression evaluates to true after all arguments have been populated then an UnexpectedArgumentException is thrown.
            </summary>
            <param name="expression">This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".</param>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.IsCurrentArgumentAllowed(PowerArgs.ArgHook.HookContext)">
            <summary>
            Determines if the current argument is allowed to be populated based on which other arguments are present and based on the expression passed to the constructor.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
            <returns>True if this argument can be specified, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Checks to see if the current argument is allowed to have a value based on which other arguments are present and based on the expression
            passed to the constructor.  If it's not allowed and has been specified then an UnexpectedArgException is thrown.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
        </member>
        <member name="P:PowerArgs.ArgCantBeCombinedWith.ExpressionText">
            <summary>
            The expression text that was passed into the constructor.  This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExistingDirectory">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a directory that exists
            as determined by System.IO.Directory.Exists(directory).
            </summary>
        </member>
        <member name="T:PowerArgs.ArgValidator">
            <summary>
            An abstract class that all validators should extend to validate user input from the command line.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgValidator.Validate(System.String,System.String@)">
            <summary>
            Most validators should just override this method. It ONLY gets called if the user specified the 
            given argument on the command line, meaning you will never get a null for 'arg'.
            
            If you want your validator to run even if the user did not specify the argument on the command line
            (for example if you were building something like [ArgRequired] then you should do 3 things.
            
            1 - Override the boolean ImplementsValidateAlways property so that it returns true
            2 - Override the ValidateAlways() method instead
            3 - Don't override the Validate() method since it will no longer be called
            
            </summary>
            <param name="name"></param>
            <param name="arg">The value specified on the command line.  If the user specified the property name, but not a value then arg will equal string.Empty.  The value will never be null.</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(System.Reflection.PropertyInfo,System.String@)">
             <summary>
             Always validates the given property, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="property">The property that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the property.  If the user specified the property name, but not a value then arg will equal string.Empty</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
             <summary>
             Always validates the given argument, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="argument">The argument that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the argument.  If the user specified the argument name, but not a value then arg will equal string.Empty</param>
        </member>
        <member name="P:PowerArgs.ArgValidator.Priority">
            <summary>
            Determines the order in which validators are executed.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.ImplementsValidateAlways">
            <summary>
            If implemented in a derived class then ValidateAlways will be called for each property,
            even if that property wasn't specified by the user on the command line.  In this case the value
            will always be null.  This is useful for implementing validators such as [ArgRequired].
            
            By default, the Validate(string,ref string) method is called unless a validator opts into ValidateAlways
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingDirectory.Validate(System.String,System.String@)">
            <summary>
            Validates that the given directory exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgExistingFile">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a file that exists
            as determined by System.IO.File.Exists(file).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingFile.Validate(System.String,System.String@)">
            <summary>
            Validates that the given file exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRange">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specified
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRange.#ctor(System.Double,System.Double)">
            <summary>
             Creates a new ArgRange validator.
            </summary>
            <param name="min">The minimum value (inclusive)</param>
            <param name="max">The maximum value (inclusive by default, set MaxIsExclusive to true to override)</param>
        </member>
        <member name="M:PowerArgs.ArgRange.Validate(System.String,System.String@)">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specifie
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="P:PowerArgs.ArgRange.MaxIsExclusive">
            <summary>
            Set to true if your max is exclusive.  This value is false by default.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgRegex">
            <summary>
            Performs regular expression validation on a property.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.regex">
            <summary>
            The regular expression to match
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.errorMessage">
            <summary>
            A prefix for the error message to show in the case of a match.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.exactMatch">
            <summary>
            The exact match that was found.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRegex.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgRegex validator.
            </summary>
            <param name="regex">The regular expression that requires an exact match to be valid</param>
            <param name="errorMessage">A prefix for the error message to show in the case of a match.</param>
        </member>
        <member name="M:PowerArgs.ArgRegex.Validate(System.String,System.String@)">
            <summary>
            Validates that the given arg exactly matches the regular expression provided.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line.</param>
        </member>
        <member name="T:PowerArgs.ArgRequired">
            <summary>
            Validates that the user actually provided a value for the given property on the command line.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.#ctor">
            <summary>
            Creates a new ArgRequired attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
            <summary>
            Validates that the user actually specified a value and optionally prompts them when it is missing.
            </summary>
            <param name="argument">The argument being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line or null if it wasn't specified</param>
        </member>
        <member name="P:PowerArgs.ArgRequired.ImplementsValidateAlways">
            <summary>
            Determines whether or not the validator should run even if the user doesn't specify a value on the command line.
            This value is always true for this validator.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.If">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IfNot">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were not specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IsConditionallyRequired">
            <summary>
            Determines if this metadata represents an argument conditionionally required.  This will be true if you've set the If or the IfNot property.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.PromptIfMissing">
            <summary>
            If you set this to true and the user didn't specify a value then the command line will prompt the user for the value.
            </summary>
        </member>
    </members>
</doc>
